<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Glass Shader Scene</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <!-- Three.js Canvas Background -->
    <canvas id="webgl"></canvas>

    <!-- ============================================= -->
    <!-- WEBFLOW HEAD CODE: Copy these 6 script tags -->
    <!-- Paste in: Page Settings ‚Üí Custom Code ‚Üí Head Code -->
    <!-- ============================================= -->
    
    <!-- Three.js r128 - Last version with working global /js/ addons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Three.js Addons for r128 - Global Script Versions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/geometries/TextGeometry.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <!-- GSAP Animation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    
    <!-- ============================================= -->
    <!-- END WEBFLOW HEAD CODE -->
    <!-- ============================================= -->
    
</body>
</html>

<!-- ============================================= -->
<!-- WEBFLOW HTML EMBED: Add this canvas element -->
<!-- Add as: HTML Embed Element on your page -->
<!-- ============================================= -->
<!-- <canvas id="webgl" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></canvas> -->
<!-- ============================================= -->
<!-- END WEBFLOW HTML EMBED -->
<!-- ============================================= -->

<!-- ============================================= -->
<!-- WEBFLOW CODE BLOCK: Copy everything between these script tags -->
<!-- Add as: Code Block Element on your page -->
<!-- ============================================= -->
<script>
        // Copy all JavaScript code from main.js here (excluding the import statements at the top)
        // Start copying from line 8: console.log('Three.js Glass Shader Scene initialized');
        // End copying at line 483: });
        
        // FIXED ISSUES:
        // ‚úÖ 1. Switched from ES modules to direct CDN scripts
        // ‚úÖ 2. Fixed FontLoader() ‚Üí THREE.FontLoader()
        // ‚úÖ 3. Fixed TextGeometry() ‚Üí THREE.TextGeometry()  
        // ‚úÖ 4. Updated font URL to GitHub CDN
        // ‚úÖ 5. Simplified initialization (no polling needed)
        // ‚úÖ 6. All libraries load synchronously now
        console.log('Three.js Glass Shader Scene initialized');

        // üîß DEVELOPMENT TOGGLE: Switch between local and GitHub CDN
        const USE_LOCAL_FILES = true; // Set to false for GitHub CDN

        // üéÆ CONTROLS TOGGLE: Enable/disable OrbitControls
        const ENABLE_ORBIT_CONTROLS = true; // Set to false to disable camera controls

        // üñ±Ô∏è MOUSE INTERACTION TOGGLE: Enable/disable mouse-driven model rotation
        const ENABLE_MOUSE_ROTATION = true; // Set to false to disable mouse rotation of bar model

        // üí° EMISSIVE TOGGLE: Switch between colored and white emissive materials
        const USE_WHITE_EMISSIVE = true; // Set to true for white emissive, false for colored
        
        // üîÜ WHITE EMISSIVE INTENSITY: Control brightness of white emissive materials
        const WHITE_EMISSIVE_INTENSITY = 1; // Adjust brightness (0.0 = off, 1.0 = normal, 2.0+ = brighter)
        

        // üéõÔ∏è LIGHTING TOGGLES: Enable/disable individual lights
        const LIGHTING_CONTROLS = {
            ambientLight: true,         // Base illumination (needed to see emissive properly)
            mainDirectionalLight: false, // Primary sun-like light
            fillLight: false,           // Secondary fill light
            rimLight: false,            // Edge highlighting
            pointLight: false,          // Dynamic highlights
            emissivePlanes: true,       // Colored/white emissive planes
            emissivePlanesVisibleToCamera: false,  // Make emissive planes visible to camera (false = only in reflections)
            emissivePlanesInReflections: false,    // Include emissive planes in glass reflections (false = completely hidden)
            backgroundPlane: false      // Show/hide the main background plane
        };

        // üéõÔ∏è BAR MODEL CONTROLS: Easy adjustment of model properties
        const BAR_MODEL = {
            scale: { x: 20.5, y: 20.5, z: 20.5 },
            position: { x: 0, y: -1, z: 3.5 
                
             },
            rotation: { 
                x: degToRad(25), // correct init 
                y: degToRad(-6.8), 
                z: degToRad(-10.687),
                order: 'YXZ' // Try different rotation orders: 'XYZ', 'YXZ', 'ZXY', 'XZY', 'YZX', 'ZYX'
             },
            showAxesHelper: false           // Show/hide XYZ axes helper
        };

        // üì∑ CAMERA CONTROLS: Easy adjustment of camera position
        const CAMERA = {
            position: { x: 0, y: 0, z: 70 },
            fov: 18 // 135mm focal length equivalent
        };

        // üìù TEXT CONTROLS: Easy adjustment of text position
        const TEXT = {
            position: { x: 0, y: 0, z: 0 } // Centered at origin
        };

        // üé® BACKGROUND PLANE CONTROLS: Main background plane
        const BACKGROUND_PLANE = {
            size: { width: 30, height: 3 },
            position: { x: 0, y: -1, z: -14 }, // Behind colored planes
            rotation: { x: degToRad(0), y: degToRad(0), z: degToRad(-10.8) }, // in radians
            color: 0xedece6 // Light cream background
        };

        // üé® COLORED PLANES CONTROLS: Easy adjustment of background planes for refraction
        const COLORED_PLANES = {
            green: {
                size: { width: 2, height: 16 },
                position: { x: -14, y: 0, z: -5.0 },
                rotation: { x: 0, y: 0, z: 0 }, // in radians
                color: 0x00ff00,        // Green base color
                emissive: 0x00ff00,     // Green emissive
                emissiveIntensity: 1.0
            },
            red: {
                size: { width: 15, height: 15 },
                position: { x: 5, y: 10, z: -5.0 },
                rotation: { x: degToRad(85), y: degToRad(-15), z: 0 }, // in radians
                color: 0xff0000,        // Red base color
                emissive: 0xff0000,     // Red emissive
                emissiveIntensity: 1.0
            },
            blue: {
                size: { width: 3, height: 20 },
                position: { x: 14, y: 0, z: -10.0 },
                rotation: { x: 0, y: 0, z: 0 }, // in radians
                color: 0x0000ff,        // Blue base color
                emissive: 0x0000ff,     // Blue emissive
                emissiveIntensity: 1.0
            },
            topDark: {
                size: { width: 40, height: 8 },
                position: { x: 0, y: 50, z: 3 },
                rotation: { x: degToRad(-45), y: degToRad(0), z: 0 }, // in radians
                color: 0x121212,        // Dark gray base color
                emissive: 0x000000,     // No emissive (pure material color)
                emissiveIntensity: 0.0
            },
            roundedRed: {
                size: { width: 30, height: 3 },
            position: { x: 0, y: -1.25, z: -14 }, // Behind colored planes
            rotation: { x: degToRad(0), y: degToRad(0), z: degToRad(-10.8) }, // in radians
                cornerRadius: 1.5,      // Corner rounding (0 = square, higher = more rounded)
                cornerSegments: 12,     // Smoothness of corners (higher = smoother)
                color: 0xedece6,        // Red base color
                emissive: 0xff0000,     // Red emissive
                emissiveIntensity: 1.0
            }
        };

        // üî¨ GLASS SHADER MATERIAL CONTROLS: Easy adjustment of glass properties
        const GLASS_SHADER = {
            // Index of Refraction values for chromatic aberration
            ior: {
                red: 1.0,
                yellow: 1.0,
                green: 1.0,
                cyan: 1.0,
                blue: 1.0,
                purple: 1.0
            },
            // Visual effects
            saturation: 1.0115,
            chromaticAberration: 0.01,
            refractPower: 0.01,
            fresnelPower: 50.0,
            shininess: 10.0,
            diffuseness: 0.5,
            // Lighting controls
            light: { 
                direction: { x: -1.0, y: 1.0, z: 1.0 },  // Light direction vector
                intensity: 0.5,                           // Overall light strength (0.0 - 2.0)
                specularStrength: 0.5,                    // Specular highlight strength (0.0 - 3.0)
                diffuseStrength: 0.5                      // Diffuse reflection strength (0.0 - 2.0)
            }
        };

        // Scene variables
        let scene, camera, renderer, canvas;
        let barModel; // Changed from mesh, wrapper to barModel
        let isModelReady = false;
        let mainRenderTarget, backRenderTarget;
        let uniforms;
        let mouseInfluence = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let mouse = { x: 0, y: 0 };
        let controls;

        // Shader code
        const vertexShader = `
        varying vec3 worldNormal;
        varying vec3 eyeVector;

        void main() {
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vec4 mvPosition = viewMatrix * worldPos;

        gl_Position = projectionMatrix * mvPosition;

        worldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
        eyeVector = normalize(worldPos.xyz - cameraPosition);
        }
        `;

        const fragmentShader = `
        uniform float uIorR;
        uniform float uIorY;
        uniform float uIorG;
        uniform float uIorC;
        uniform float uIorB;
        uniform float uIorP;

        uniform float uSaturation;
        uniform float uChromaticAberration;
        uniform float uRefractPower;
        uniform float uFresnelPower;
        uniform float uShininess;
        uniform float uDiffuseness;
        uniform vec3 uLight;
        uniform float uLightIntensity;
        uniform float uSpecularStrength;
        uniform float uDiffuseStrength;

        uniform vec2 winResolution;
        uniform sampler2D uTexture;

        varying vec3 worldNormal;
        varying vec3 eyeVector;

        vec3 sat(vec3 rgb, float adjustment) {
        const vec3 W = vec3(0.2125, 0.7154, 0.0721);
        vec3 intensity = vec3(dot(rgb, W));
        return mix(intensity, rgb, adjustment);
        }

        float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {
        float fresnelFactor = abs(dot(eyeVector, worldNormal));
        float inversefresnelFactor = 1.0 - fresnelFactor;
        
        return pow(inversefresnelFactor, power);
        }

        float specular(vec3 light, float shininess, float diffuseness) {
        vec3 normal = worldNormal;
        vec3 lightVector = normalize(-light);
        vec3 halfVector = normalize(eyeVector + lightVector);

        float NdotL = dot(normal, lightVector);
        float NdotH =  dot(normal, halfVector);
        float kDiffuse = max(0.0, NdotL);
        float NdotH2 = NdotH * NdotH;

        float kSpecular = pow(NdotH2, shininess);
        return  kSpecular + kDiffuse * diffuseness;
        }

        const int LOOP = 16;

        void main() {
        float iorRatioRed = 1.0/uIorR;
        float iorRatioGreen = 1.0/uIorG;
        float iorRatioBlue = 1.0/uIorB;

        vec2 uv = gl_FragCoord.xy / winResolution.xy;
        vec3 normal = worldNormal;
        vec3 color = vec3(0.0);

        for ( int i = 0; i < LOOP; i ++ ) {
            float slide = float(i) / float(LOOP) * 0.1;

            vec3 refractVecR = refract(eyeVector, normal,(1.0/uIorR));
            vec3 refractVecY = refract(eyeVector, normal, (1.0/uIorY));
            vec3 refractVecG = refract(eyeVector, normal, (1.0/uIorG));
            vec3 refractVecC = refract(eyeVector, normal, (1.0/uIorC));
            vec3 refractVecB = refract(eyeVector, normal, (1.0/uIorB));
            vec3 refractVecP = refract(eyeVector, normal, (1.0/uIorP));

            float r = texture2D(uTexture, uv + refractVecR.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;

            float y = (texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;

            float g = texture2D(uTexture, uv + refractVecG.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;

            float c = (texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;
                
            float b = texture2D(uTexture, uv + refractVecB.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;

            float p = (texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;

            float R = r + (2.0*p + 2.0*y - c)/3.0;
            float G = g + (2.0*y + 2.0*c - p)/3.0;
            float B = b + (2.0*c + 2.0*p - y)/3.0;

            color.r += R;
            color.g += G;
            color.b += B;

            color = sat(color, uSaturation);
        }

        // Divide by the number of layers to normalize colors (rgb values can be worth up to the value of LOOP)
        color /= float( LOOP );

        // Specular with intensity controls
        float specularLight = specular(uLight, uShininess, uDiffuseness * uDiffuseStrength);
        color += specularLight * uSpecularStrength * uLightIntensity;

        // Fresnel
        float f = fresnel(eyeVector, normal, uFresnelPower);
        color.rgb += f * vec3(1.0);

        gl_FragColor = vec4(color, 1.0);
        }
        `;

        // Initialize Three.js scene
        function init() {
            
            // Get canvas
            canvas = document.getElementById('webgl');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = null; // Transparent background
            
            // Create camera with controls from constants
            camera = new THREE.PerspectiveCamera(CAMERA.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(CAMERA.position.x, CAMERA.position.y, CAMERA.position.z);
            
            // Set up camera layers
            // Layer 0: Default layer (visible to camera and reflections)
            // Layer 1: Reflection-only layer (invisible to camera, visible in reflections)
            camera.layers.enable(0); // Enable default layer
            if (LIGHTING_CONTROLS.emissivePlanesVisibleToCamera) {
                camera.layers.enable(1); // Enable reflection-only layer if planes should be visible
            } else {
                camera.layers.disable(1); // Disable reflection-only layer to hide from camera
            }
            
            
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true,
                antialias: true 
            });
            
            // Proper DPI-aware canvas sizing
            function resizeCanvasToDisplaySize() {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // Critical: pass false to prevent CSS fighting
                const pixelRatio = Math.min(window.devicePixelRatio, 2);
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(width, height, false);
                
                // Update camera aspect ratio
                camera.aspect = width / height;
                camera.clearViewOffset(); // Clear any existing offset
                camera.updateProjectionMatrix();
                
                return canvas.width !== width * pixelRatio || canvas.height !== height * pixelRatio;
            }
            
            // Initial resize
            resizeCanvasToDisplaySize();
            renderer.setClearColor(0x000000, 0);
            
            // Create render targets with full window resolution like GitHub version
            mainRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            backRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            
            // Initialize uniforms using GLASS_SHADER configuration
            uniforms = {
                uIorR: { value: GLASS_SHADER.ior.red },
                uIorY: { value: GLASS_SHADER.ior.yellow },
                uIorG: { value: GLASS_SHADER.ior.green },
                uIorC: { value: GLASS_SHADER.ior.cyan },
                uIorB: { value: GLASS_SHADER.ior.blue },
                uIorP: { value: GLASS_SHADER.ior.purple },
                uSaturation: { value: GLASS_SHADER.saturation },
                uChromaticAberration: { value: GLASS_SHADER.chromaticAberration },
                uRefractPower: { value: GLASS_SHADER.refractPower },
                uFresnelPower: { value: GLASS_SHADER.fresnelPower },
                uShininess: { value: GLASS_SHADER.shininess },
                uDiffuseness: { value: GLASS_SHADER.diffuseness },
                uLight: { value: new THREE.Vector3(GLASS_SHADER.light.direction.x, GLASS_SHADER.light.direction.y, GLASS_SHADER.light.direction.z) },
                uLightIntensity: { value: GLASS_SHADER.light.intensity },
                uSpecularStrength: { value: GLASS_SHADER.light.specularStrength },
                uDiffuseStrength: { value: GLASS_SHADER.light.diffuseStrength },
                winResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight).multiplyScalar(Math.min(window.devicePixelRatio, 2)) },
                uTexture: { value: null }
            };
            
            // Add comprehensive lighting setup with toggles
            // Ambient light for overall illumination
            if (LIGHTING_CONTROLS.ambientLight) {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
            }
            
            // Main directional light
            if (LIGHTING_CONTROLS.mainDirectionalLight) {
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(5, 5, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
            }
            
            // Secondary directional light for fill
            if (LIGHTING_CONTROLS.fillLight) {
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
                fillLight.position.set(-5, 3, 5);
                scene.add(fillLight);
            }
            
            // Rim light for edge highlighting
            if (LIGHTING_CONTROLS.rimLight) {
                const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
                rimLight.position.set(0, -5, 5);
                scene.add(rimLight);
            }
            
            // Point light for dynamic highlights
            if (LIGHTING_CONTROLS.pointLight) {
                const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
                pointLight.position.set(0, 0, 10);
                scene.add(pointLight);
            }
            
            // Create background geometry for refraction effects
            createBackgroundGeometry();
            
            // Create 3D text
            create3DText();
            
            // Load GLTF model
            loadBarModel();
            
            // Initialize OrbitControls
            initializeOrbitControls();
            
            // Add event listeners
            addEventListeners();
        }

        function degToRad(deg) {
            return deg * (Math.PI / 180);
        }

        // Create rounded rectangle geometry
        function createRoundedRectangleGeometry(width, height, radius, segments = 8) {
            const shape = new THREE.Shape();
            const x = -width / 2;
            const y = -height / 2;
            
            // Start from bottom-left corner, moving clockwise
            shape.moveTo(x + radius, y);
            
            // Bottom edge
            shape.lineTo(x + width - radius, y);
            
            // Bottom-right corner
            shape.quadraticCurveTo(x + width, y, x + width, y + radius);
            
            // Right edge
            shape.lineTo(x + width, y + height - radius);
            
            // Top-right corner
            shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            
            // Top edge
            shape.lineTo(x + radius, y + height);
            
            // Top-left corner
            shape.quadraticCurveTo(x, y + height, x, y + height - radius);
            
            // Left edge
            shape.lineTo(x, y + radius);
            
            // Bottom-left corner
            shape.quadraticCurveTo(x, y, x + radius, y);
            
            return new THREE.ShapeGeometry(shape, segments);
        }

        // Create background plane and colored emissive planes for refraction effects
        function createBackgroundGeometry() {
            // Create main background plane (behind everything) - only if enabled
            if (LIGHTING_CONTROLS.backgroundPlane) {
                const backgroundGeometry = new THREE.PlaneGeometry(BACKGROUND_PLANE.size.width, BACKGROUND_PLANE.size.height);
                const backgroundMaterial = new THREE.MeshBasicMaterial({ 
                    color: BACKGROUND_PLANE.color, 
                    side: THREE.DoubleSide 
                });
                const backgroundPlane = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
                backgroundPlane.position.set(BACKGROUND_PLANE.position.x, BACKGROUND_PLANE.position.y, BACKGROUND_PLANE.position.z);
                backgroundPlane.rotation.set(BACKGROUND_PLANE.rotation.x, BACKGROUND_PLANE.rotation.y, BACKGROUND_PLANE.rotation.z);
                scene.add(backgroundPlane);
            }

            // Create emissive planes only if enabled
            if (LIGHTING_CONTROLS.emissivePlanes) {
                // Create green plane with toggle-able material
                const greenGeometry = new THREE.PlaneGeometry(COLORED_PLANES.green.size.width, COLORED_PLANES.green.size.height);
                const greenEmissiveColor = USE_WHITE_EMISSIVE ? 
                    new THREE.Color(WHITE_EMISSIVE_INTENSITY, WHITE_EMISSIVE_INTENSITY, WHITE_EMISSIVE_INTENSITY) : 
                    COLORED_PLANES.green.emissive;
                const greenMaterial = new THREE.MeshBasicMaterial({
                    color: USE_WHITE_EMISSIVE ? 0x000000 : COLORED_PLANES.green.color,
                    emissive: greenEmissiveColor,
                    side: THREE.DoubleSide
                });
                const greenPlane = new THREE.Mesh(greenGeometry, greenMaterial);
                greenPlane.position.set(COLORED_PLANES.green.position.x, COLORED_PLANES.green.position.y, COLORED_PLANES.green.position.z);
                greenPlane.rotation.set(COLORED_PLANES.green.rotation.x, COLORED_PLANES.green.rotation.y, COLORED_PLANES.green.rotation.z);
                // Set layer based on visibility toggles
                if (!LIGHTING_CONTROLS.emissivePlanesInReflections) {
                    greenPlane.layers.set(2); // Completely hidden layer (invisible to camera AND reflections)
                } else if (LIGHTING_CONTROLS.emissivePlanesVisibleToCamera) {
                    greenPlane.layers.set(0); // Default layer (visible to camera and reflections)
                } else {
                    greenPlane.layers.set(1); // Reflection-only layer (invisible to camera, visible in reflections)
                }
                scene.add(greenPlane);

                // Create red plane with toggle-able material
                const redGeometry = new THREE.PlaneGeometry(COLORED_PLANES.red.size.width, COLORED_PLANES.red.size.height);
                const redEmissiveColor = USE_WHITE_EMISSIVE ? 
                    new THREE.Color(WHITE_EMISSIVE_INTENSITY, WHITE_EMISSIVE_INTENSITY, WHITE_EMISSIVE_INTENSITY) : 
                    COLORED_PLANES.red.emissive;
                const redMaterial = new THREE.MeshBasicMaterial({
                    color: USE_WHITE_EMISSIVE ? 0x000000 : COLORED_PLANES.red.color,
                    emissive: redEmissiveColor,
                    side: THREE.DoubleSide
                });
                const redPlane = new THREE.Mesh(redGeometry, redMaterial);
                redPlane.position.set(COLORED_PLANES.red.position.x, COLORED_PLANES.red.position.y, COLORED_PLANES.red.position.z);
                redPlane.rotation.set(COLORED_PLANES.red.rotation.x, COLORED_PLANES.red.rotation.y, COLORED_PLANES.red.rotation.z);
                // Set layer based on visibility toggles
                if (!LIGHTING_CONTROLS.emissivePlanesInReflections) {
                    redPlane.layers.set(2); // Completely hidden layer (invisible to camera AND reflections)
                } else if (LIGHTING_CONTROLS.emissivePlanesVisibleToCamera) {
                    redPlane.layers.set(0); // Default layer (visible to camera and reflections)
                } else {
                    redPlane.layers.set(1); // Reflection-only layer (invisible to camera, visible in reflections)
                }
                scene.add(redPlane);

                // Create blue plane with toggle-able material
                const blueGeometry = new THREE.PlaneGeometry(COLORED_PLANES.blue.size.width, COLORED_PLANES.blue.size.height);
                const blueEmissiveColor = USE_WHITE_EMISSIVE ? 
                    new THREE.Color(WHITE_EMISSIVE_INTENSITY, WHITE_EMISSIVE_INTENSITY, WHITE_EMISSIVE_INTENSITY) : 
                    COLORED_PLANES.blue.emissive;
                const blueMaterial = new THREE.MeshBasicMaterial({
                    color: USE_WHITE_EMISSIVE ? 0x000000 : COLORED_PLANES.blue.color,
                    emissive: blueEmissiveColor,
                    side: THREE.DoubleSide
                });
                const bluePlane = new THREE.Mesh(blueGeometry, blueMaterial);
                bluePlane.position.set(COLORED_PLANES.blue.position.x, COLORED_PLANES.blue.position.y, COLORED_PLANES.blue.position.z);
                bluePlane.rotation.set(COLORED_PLANES.blue.rotation.x, COLORED_PLANES.blue.rotation.y, COLORED_PLANES.blue.rotation.z);
                // Set layer based on visibility toggles
                if (!LIGHTING_CONTROLS.emissivePlanesInReflections) {
                    bluePlane.layers.set(2); // Completely hidden layer (invisible to camera AND reflections)
                } else if (LIGHTING_CONTROLS.emissivePlanesVisibleToCamera) {
                    bluePlane.layers.set(0); // Default layer (visible to camera and reflections)
                } else {
                    bluePlane.layers.set(1); // Reflection-only layer (invisible to camera, visible in reflections)
                }
                scene.add(bluePlane);

                // Create top dark plane (always black, ignores white emissive toggle)
                const topDarkGeometry = new THREE.PlaneGeometry(COLORED_PLANES.topDark.size.width, COLORED_PLANES.topDark.size.height);
                const topDarkMaterial = new THREE.MeshBasicMaterial({
                    color: COLORED_PLANES.topDark.color,        // Always use the configured color (black)
                    emissive: COLORED_PLANES.topDark.emissive,  // Always use the configured emissive
                    emissiveIntensity: COLORED_PLANES.topDark.emissiveIntensity,
                    side: THREE.DoubleSide
                });
                const topDarkPlane = new THREE.Mesh(topDarkGeometry, topDarkMaterial);
                topDarkPlane.position.set(COLORED_PLANES.topDark.position.x, COLORED_PLANES.topDark.position.y, COLORED_PLANES.topDark.position.z);
                topDarkPlane.rotation.set(COLORED_PLANES.topDark.rotation.x, COLORED_PLANES.topDark.rotation.y, COLORED_PLANES.topDark.rotation.z);
                scene.add(topDarkPlane);
            }

            // Create rounded red plane for testing (always visible, independent of emissive planes toggle)
            const roundedRedGeometry = createRoundedRectangleGeometry(
                COLORED_PLANES.roundedRed.size.width, 
                COLORED_PLANES.roundedRed.size.height, 
                COLORED_PLANES.roundedRed.cornerRadius, 
                COLORED_PLANES.roundedRed.cornerSegments
            );
            const roundedRedMaterial = new THREE.MeshBasicMaterial({
                color: COLORED_PLANES.roundedRed.color,        // Always use configured color
                emissive: COLORED_PLANES.roundedRed.emissive,  // Always use configured emissive
                emissiveIntensity: COLORED_PLANES.roundedRed.emissiveIntensity,
                side: THREE.DoubleSide
            });
            const roundedRedPlane = new THREE.Mesh(roundedRedGeometry, roundedRedMaterial);
            roundedRedPlane.position.set(COLORED_PLANES.roundedRed.position.x, COLORED_PLANES.roundedRed.position.y, COLORED_PLANES.roundedRed.position.z);
            roundedRedPlane.rotation.set(COLORED_PLANES.roundedRed.rotation.x, COLORED_PLANES.roundedRed.rotation.y, COLORED_PLANES.roundedRed.rotation.z);
            // Always visible to camera (not affected by any toggles)
            roundedRedPlane.layers.set(0); // Always on default layer
            scene.add(roundedRedPlane);
        }

        // Create 3D text
        function create3DText() {
            
            const fontLoader = new THREE.FontLoader();
            
            // Load Outfit font (converted to Three.js typeface format)
            fontLoader.load(
                'https://raw.githubusercontent.com/gorillabiscuit/cerebral-webflow/master/fonts/Outfit_Regular.json',
                (font) => {
                    // Create text geometry
                    const textGeometry = new THREE.TextGeometry('cerebral', {
                        font: font,
                        size: 5, // Text size
                        height: 0.00001, // Text depth/extrusion
                        curveSegments: 12,
                        bevelEnabled: false,
                        // bevelThickness: 0.03,
                        // bevelSize: 0.02,
                        // bevelOffset: 0,
                        // bevelSegments: 5
                    });
                    
                    // Center the text geometry
                    textGeometry.computeBoundingBox();
                    const bbox = textGeometry.boundingBox;
                    
                    const centerOffsetX = -(bbox.max.x + bbox.min.x) / 2;
                    const centerOffsetY = -(bbox.max.y + bbox.min.y) / 2;
                    const centerOffsetZ = 0; // Force Z-centering to 0 to prevent depth artifacts
                    
                    // Create dark gray material for text
                    const textMaterial = new THREE.MeshBasicMaterial({ color: 0x121212 });
                    
                    // Create text mesh
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.name = 'cerebralText'; // Add name for easy reference
                    
                    // Position text using constants + centering offsets
                    textMesh.position.set(
                        TEXT.position.x + centerOffsetX, 
                        TEXT.position.y + centerOffsetY, 
                        TEXT.position.z + centerOffsetZ
                    );
                    
                    // Add to scene
                    scene.add(textMesh);
                },
                undefined, // No progress callback needed
                (error) => {
                    console.error('Error loading font:', error);
                }
            );
        }

        // Load GLTF model
        function loadBarModel() {
            // Check if GLTFLoader is available
            if (typeof THREE.GLTFLoader === 'undefined') {
                console.warn('GLTFLoader not available, skipping bar model');
                return;
            }
            
            const gltfLoader = new THREE.GLTFLoader();
            
            // Load bar.glb model - toggle between local and GitHub CDN
            const modelUrl = USE_LOCAL_FILES 
                ? './models/bar.glb'  // Local file for fast iteration
                : 'https://raw.githubusercontent.com/gorillabiscuit/cerebral-webflow/master/models/bar.glb'; // GitHub CDN
            
            console.log('Loading bar model from:', USE_LOCAL_FILES ? 'LOCAL' : 'GITHUB CDN');
            gltfLoader.load(
                modelUrl,
                (gltf) => {
                    console.log('Bar model loaded successfully');
                    barModel = gltf.scene; // Assign to global variable
                    
                    // Center the geometry itself for proper positioning
                    const box = new THREE.Box3().setFromObject(barModel);
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // Apply centering transformation to ALL child geometries
                    barModel.traverse((child) => {
                        if (child.isMesh && child.geometry) {
                            // r128 compatible geometry translation
                            if (typeof child.geometry.translate === 'function') {
                                child.geometry.translate(-center.x, -center.y, -center.z);
                            } else {
                                // Fallback for r128 - manual vertex translation
                                if (child.geometry.attributes && child.geometry.attributes.position) {
                                    const positions = child.geometry.attributes.position.array;
                                    for (let i = 0; i < positions.length; i += 3) {
                                        positions[i] -= center.x;     // x
                                        positions[i + 1] -= center.y; // y  
                                        positions[i + 2] -= center.z; // z
                                    }
                                    child.geometry.attributes.position.needsUpdate = true;
                                }
                            }
                        }
                    });
                    
                    // Add XYZ axes helper at origin (model should now be truly centered here) - only if enabled
                    if (BAR_MODEL.showAxesHelper) {
                        const axesHelper = new THREE.AxesHelper(1);
                        axesHelper.position.set(0, 0, 0);
                        barModel.add(axesHelper);
                    }
                    
                    // Apply model transformations normally - geometry is now truly centered
                    barModel.scale.set(BAR_MODEL.scale.x, BAR_MODEL.scale.y, BAR_MODEL.scale.z);
                    barModel.position.set(BAR_MODEL.position.x, BAR_MODEL.position.y, BAR_MODEL.position.z);
                    
                    // üîß IMPROVED ROTATION: Set rotation order first, then apply rotations
                    barModel.rotation.order = BAR_MODEL.rotation.order;
                    barModel.rotation.set(BAR_MODEL.rotation.x, BAR_MODEL.rotation.y, BAR_MODEL.rotation.z);
                    
                    
                    // Ensure OrbitControls target the origin
                    if (controls) {
                        controls.target.set(0, 0, 0);
                        controls.update();
                    }
                    
                    // Apply glass shader material to all meshes in the model
                    const glassShaderMaterial = new THREE.ShaderMaterial({
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        uniforms: uniforms,
                        side: THREE.DoubleSide
                    });
                    
                    barModel.traverse((child) => {
                        if (child.isMesh) {
                            child.material = glassShaderMaterial;
                        }
                    });
                    
                    // Add to scene
                    scene.add(barModel);
                    
                    // Set model ready flag
                    isModelReady = true;
                    console.log('Bar model ready for rendering');
                    
                    // Optional: Add the model to the wrapper for mouse interactions
                    // wrapper.add(barModel);
                },
                (progress) => {
                    console.log('Loading bar model:', (progress.loaded / progress.total * 100) + '%');
                },
                (error) => {
                    console.error('Error loading bar model:', error);
                }
            );
        }



        // Initialize OrbitControls
        function initializeOrbitControls() {
            // Check if OrbitControls should be enabled
            if (!ENABLE_ORBIT_CONTROLS) {
                console.log('OrbitControls disabled by ENABLE_ORBIT_CONTROLS setting');
                return;
            }
            
            // Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('OrbitControls not available');
                return;
            }
            
            controls = new THREE.OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            controls.autoRotate = false;
            controls.autoRotateSpeed = 2.0;
            
            console.log('OrbitControls initialized');
        }

        // Add event listeners
        function addEventListeners() {
            // Mouse move handler for cube rotation
            window.addEventListener('mousemove', (e) => {
                // Update mouse position for cube rotation
                mouse.x = e.clientX / window.innerWidth - 0.5;
                mouse.y = e.clientY / window.innerHeight - 0.5;
                
                // Initialize lastMousePos if it hasn't been set yet
                if (lastMousePos.x === 0 && lastMousePos.y === 0) {
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    return;
                }
                
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                // Add mouse movement to influence (normalized to screen size)
                mouseInfluence.x += deltaX / window.innerWidth * 2.0;
                mouseInfluence.y += deltaY / window.innerHeight * 2.0;
                
                lastMousePos.x = e.clientX;
                lastMousePos.y = e.clientY;
            });
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        // Window resize handler
        function onWindowResize() {
            // Use proper DPI-aware resize function
            resizeCanvasToDisplaySize();
            
            // Update render targets with new size
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            const width = canvas.clientWidth * pixelRatio;
            const height = canvas.clientHeight * pixelRatio;
            
            mainRenderTarget.setSize(width, height);
            backRenderTarget.setSize(width, height);
            
            // Update uniforms
            uniforms.winResolution.value.set(canvas.clientWidth, canvas.clientHeight).multiplyScalar(pixelRatio);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update OrbitControls if available
            if (controls) {
                controls.update();
            }
            
            // Rotate bar model based on mouse position using GSAP (with toggle)
            if (barModel && isModelReady && ENABLE_MOUSE_ROTATION) {
                gsap.to(barModel.rotation, {
                    x: mouse.y * 0.5,
                    y: mouse.x * 0.5,
                    duration: 0.8,
                    ease: "power2.out",
                    overwrite: "auto"
                });
            }
            
            // Glass refraction rendering with two-pass system
            if (barModel && isModelReady) {
                // Temporarily enable layers for reflection rendering (exclude completely hidden layer 2)
                const originalLayers = camera.layers.mask;
                if (LIGHTING_CONTROLS.emissivePlanesInReflections) {
                    camera.layers.enableAll(); // Enable all layers for reflections
                } else {
                    // Enable layers 0 and 1, but exclude layer 2 (completely hidden)
                    camera.layers.disableAll();
                    camera.layers.enable(0); // Default objects
                    camera.layers.enable(1); // Reflection-only objects
                    // Layer 2 (completely hidden) remains disabled
                }
                
                // First pass: Hide glass model and render background to back target
                barModel.visible = false;
                renderer.setRenderTarget(backRenderTarget);
                renderer.render(scene, camera);
                
                // Update glass material uniforms and set to back side
                barModel.traverse((child) => {
                    if (child.isMesh && child.material.uniforms) {
                        child.material.uniforms.uTexture.value = backRenderTarget.texture;
                        child.material.side = THREE.BackSide;
                    }
                });
                
                barModel.visible = true;
                
                // Second pass: Render with glass model to main target
                renderer.setRenderTarget(mainRenderTarget);
                renderer.render(scene, camera);
                
                // Update glass material uniforms and set to front side
                barModel.traverse((child) => {
                    if (child.isMesh && child.material.uniforms) {
                        child.material.uniforms.uTexture.value = mainRenderTarget.texture;
                        child.material.side = THREE.FrontSide;
                    }
                });
                
                renderer.setRenderTarget(null);
                
                // Restore original camera layers for final render
                camera.layers.mask = originalLayers;
            }
            
            // Final render to screen (respects layer visibility)
            renderer.render(scene, camera);
        }

        // Initialize when everything is loaded
        window.addEventListener('load', () => {
            console.log('All libraries loaded, initializing scene...');
            console.log('THREE available:', typeof THREE !== 'undefined');
            console.log('GSAP available:', typeof gsap !== 'undefined');
            
            if (typeof THREE === 'undefined') {
                console.error('THREE.js failed to load! Check CDN URLs');
                return;
            }
            
            console.log('THREE.REVISION:', THREE.REVISION);
            console.log('THREE.FontLoader available:', typeof THREE.FontLoader !== 'undefined');
            console.log('THREE.TextGeometry available:', typeof THREE.TextGeometry !== 'undefined');
            console.log('THREE.OrbitControls available:', typeof THREE.OrbitControls !== 'undefined');
            console.log('THREE.GLTFLoader available:', typeof THREE.GLTFLoader !== 'undefined');
            init();
            animate();
        });
</script>
<!-- ============================================= -->
<!-- END WEBFLOW CODE BLOCK -->
<!-- ============================================= -->