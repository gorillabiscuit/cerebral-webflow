<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Glass Shader Scene</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <!-- Three.js Canvas Background -->
    <canvas id="webgl"></canvas>

    <!-- ============================================= -->
    <!-- WEBFLOW HEAD CODE: Copy these 6 script tags -->
    <!-- Paste in: Page Settings ‚Üí Custom Code ‚Üí Head Code -->
    <!-- ============================================= -->
    
    <!-- Three.js r128 - Last version with working global /js/ addons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Three.js Addons for r128 - Global Script Versions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/FontLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/geometries/TextGeometry.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <!-- GSAP Animation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    
    <!-- ============================================= -->
    <!-- END WEBFLOW HEAD CODE -->
    <!-- ============================================= -->
    
</body>
</html>

<!-- ============================================= -->
<!-- WEBFLOW HTML EMBED: Add this canvas element -->
<!-- Add as: HTML Embed Element on your page -->
<!-- ============================================= -->
<!-- <canvas id="webgl" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;"></canvas> -->
<!-- ============================================= -->
<!-- END WEBFLOW HTML EMBED -->
<!-- ============================================= -->

<!-- ============================================= -->
<!-- WEBFLOW CODE BLOCK: Copy everything between these script tags -->
<!-- Add as: Code Block Element on your page -->
<!-- ============================================= -->
<script>
        // Copy all JavaScript code from main.js here (excluding the import statements at the top)
        // Start copying from line 8: console.log('Three.js Glass Shader Scene initialized');
        // End copying at line 483: });
        
        // FIXED ISSUES:
        // ‚úÖ 1. Switched from ES modules to direct CDN scripts
        // ‚úÖ 2. Fixed FontLoader() ‚Üí THREE.FontLoader()
        // ‚úÖ 3. Fixed TextGeometry() ‚Üí THREE.TextGeometry()  
        // ‚úÖ 4. Updated font URL to GitHub CDN
        // ‚úÖ 5. Simplified initialization (no polling needed)
        // ‚úÖ 6. All libraries load synchronously now
        console.log('Three.js Glass Shader Scene initialized');

        // üîß DEVELOPMENT TOGGLE: Switch between local and GitHub CDN
        const USE_LOCAL_FILES = true; // Set to false for GitHub CDN

        // üéÆ CONTROLS TOGGLE: Enable/disable OrbitControls
        const ENABLE_ORBIT_CONTROLS = true; // Set to false to disable camera controls

        // üéõÔ∏è BAR MODEL CONTROLS: Easy adjustment of model properties
        const BAR_MODEL = {
            scale: { x: 19, y: 19, z: 19 },
            position: { x: 0, y: 0, z: 0
                
             },
            rotation: { 
                x: degToRad(0), 
                y: degToRad(90), 
                z: degToRad(0)
             } // 90 degrees on Y axis
            // rotation: { x: 0, y: Math.PI / 2, z: 0 } // 90 degrees on Y axis
        };

        // üì∑ CAMERA CONTROLS: Easy adjustment of camera position
        const CAMERA = {
            position: { x: 0, y: 0, z: 133.6 },
            fov: 18 // 135mm focal length equivalent
        };

        // üìù TEXT CONTROLS: Easy adjustment of text position
        const TEXT = {
            position: { x: 0, y: 0, z: 0 } // Centered at origin
        };

        // Scene variables
        let scene, camera, renderer, canvas;
        let mesh, wrapper;
        let isModelReady = false;
        let mainRenderTarget, backRenderTarget;
        let uniforms;
        let mouseInfluence = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let mouse = { x: 0, y: 0 };
        let controls;

        // Shader code
        const vertexShader = `
        varying vec3 worldNormal;
        varying vec3 eyeVector;

        void main() {
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vec4 mvPosition = viewMatrix * worldPos;

        gl_Position = projectionMatrix * mvPosition;

        worldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
        eyeVector = normalize(worldPos.xyz - cameraPosition);
        }
        `;

        const fragmentShader = `
        uniform float uIorR;
        uniform float uIorY;
        uniform float uIorG;
        uniform float uIorC;
        uniform float uIorB;
        uniform float uIorP;

        uniform float uSaturation;
        uniform float uChromaticAberration;
        uniform float uRefractPower;
        uniform float uFresnelPower;
        uniform float uShininess;
        uniform float uDiffuseness;
        uniform vec3 uLight;

        uniform vec2 winResolution;
        uniform sampler2D uTexture;

        varying vec3 worldNormal;
        varying vec3 eyeVector;

        vec3 sat(vec3 rgb, float adjustment) {
        const vec3 W = vec3(0.2125, 0.7154, 0.0721);
        vec3 intensity = vec3(dot(rgb, W));
        return mix(intensity, rgb, adjustment);
        }

        float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {
        float fresnelFactor = abs(dot(eyeVector, worldNormal));
        float inversefresnelFactor = 1.0 - fresnelFactor;
        
        return pow(inversefresnelFactor, power);
        }

        float specular(vec3 light, float shininess, float diffuseness) {
        vec3 normal = worldNormal;
        vec3 lightVector = normalize(-light);
        vec3 halfVector = normalize(eyeVector + lightVector);

        float NdotL = dot(normal, lightVector);
        float NdotH =  dot(normal, halfVector);
        float kDiffuse = max(0.0, NdotL);
        float NdotH2 = NdotH * NdotH;

        float kSpecular = pow(NdotH2, shininess);
        return  kSpecular + kDiffuse * diffuseness;
        }

        const int LOOP = 16;

        void main() {
        float iorRatioRed = 1.0/uIorR;
        float iorRatioGreen = 1.0/uIorG;
        float iorRatioBlue = 1.0/uIorB;

        vec2 uv = gl_FragCoord.xy / winResolution.xy;
        vec3 normal = worldNormal;
        vec3 color = vec3(0.0);

        for ( int i = 0; i < LOOP; i ++ ) {
            float slide = float(i) / float(LOOP) * 0.1;

            vec3 refractVecR = refract(eyeVector, normal,(1.0/uIorR));
            vec3 refractVecY = refract(eyeVector, normal, (1.0/uIorY));
            vec3 refractVecG = refract(eyeVector, normal, (1.0/uIorG));
            vec3 refractVecC = refract(eyeVector, normal, (1.0/uIorC));
            vec3 refractVecB = refract(eyeVector, normal, (1.0/uIorB));
            vec3 refractVecP = refract(eyeVector, normal, (1.0/uIorP));

            float r = texture2D(uTexture, uv + refractVecR.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;

            float y = (texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;

            float g = texture2D(uTexture, uv + refractVecG.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;

            float c = (texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;
                
            float b = texture2D(uTexture, uv + refractVecB.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;

            float p = (texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;

            float R = r + (2.0*p + 2.0*y - c)/3.0;
            float G = g + (2.0*y + 2.0*c - p)/3.0;
            float B = b + (2.0*c + 2.0*p - y)/3.0;

            color.r += R;
            color.g += G;
            color.b += B;

            color = sat(color, uSaturation);
        }

        // Divide by the number of layers to normalize colors (rgb values can be worth up to the value of LOOP)
        color /= float( LOOP );

        // Specular
        float specularLight = specular(uLight, uShininess, uDiffuseness);
        color += specularLight;

        // Fresnel
        float f = fresnel(eyeVector, normal, uFresnelPower);
        color.rgb += f * vec3(1.0);

        gl_FragColor = vec4(color, 0.5); // 50% transparency
        }
        `;

        // Initialize Three.js scene
        function init() {
            
            // Get canvas
            canvas = document.getElementById('webgl');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = null; // Transparent background
            
            // Create camera with controls from constants
            camera = new THREE.PerspectiveCamera(CAMERA.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(CAMERA.position.x, CAMERA.position.y, CAMERA.position.z);
            
            // üîç CAMERA DEBUG: Check if camera is properly configured
            console.log('=== CAMERA CONFIGURATION DEBUG ===');
            console.log('Camera position:', camera.position);
            console.log('Camera target (where it looks):', camera.getWorldDirection(new THREE.Vector3()));
            console.log('Camera aspect ratio:', camera.aspect);
            console.log('Window dimensions:', window.innerWidth, 'x', window.innerHeight);
            console.log('Camera FOV:', camera.fov);
            
            // Check if camera is looking at origin by default
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            console.log('Camera looking direction:', lookDirection);
            
            // Calculate where camera is pointing in world space
            const cameraTarget = new THREE.Vector3();
            cameraTarget.copy(camera.position).add(lookDirection.multiplyScalar(100));
            console.log('Camera pointing at world position:', cameraTarget);
            
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true,
                antialias: true 
            });
            
            // üîß FIX 1: Proper DPI-aware canvas sizing
            function resizeCanvasToDisplaySize() {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                console.log('=== CANVAS RESIZE DEBUG ===');
                console.log('Client dimensions:', width, 'x', height);
                console.log('Current canvas dimensions:', canvas.width, 'x', canvas.height);
                console.log('Device pixel ratio:', window.devicePixelRatio);
                
                // Critical: pass false to prevent CSS fighting
                const pixelRatio = Math.min(window.devicePixelRatio, 2);
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(width, height, false);
                
                // Update camera aspect ratio
                camera.aspect = width / height;
                camera.clearViewOffset(); // Clear any existing offset
                camera.updateProjectionMatrix();
                
                console.log('After resize - Canvas:', canvas.width, 'x', canvas.height);
                console.log('After resize - Client:', canvas.clientWidth, 'x', canvas.clientHeight);
                console.log('Camera aspect ratio:', camera.aspect);
                
                return canvas.width !== width * pixelRatio || canvas.height !== height * pixelRatio;
            }
            
            // Initial resize
            resizeCanvasToDisplaySize();
            
            // üîç RENDERER DEBUG: Check canvas and renderer configuration
            console.log('=== RENDERER CONFIGURATION DEBUG ===');
            console.log('Canvas element:', canvas);
            console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
            console.log('Canvas client dimensions:', canvas.clientWidth, 'x', canvas.clientHeight);
            console.log('Canvas style:', canvas.style.cssText);
            console.log('Renderer size:', renderer.getSize(new THREE.Vector2()));
            console.log('Pixel ratio:', renderer.getPixelRatio());
            
            // Check canvas position in viewport
            const canvasRect = canvas.getBoundingClientRect();
            console.log('Canvas position in viewport:', canvasRect);
            console.log('Canvas offset from top-left:', canvasRect.left, canvasRect.top);
            
            // üîß VIEWPORT CENTERING TEST
            console.log('=== VIEWPORT CENTERING TEST ===');
            console.log('Viewport center should be:', window.innerWidth / 2, window.innerHeight / 2);
            console.log('Canvas center is:', canvasRect.left + canvasRect.width / 2, canvasRect.top + canvasRect.height / 2);
            console.log('Canvas covers full viewport?', 
                canvasRect.left === 0 && 
                canvasRect.top === 0 && 
                canvasRect.width === window.innerWidth && 
                canvasRect.height === window.innerHeight
            );
            renderer.setClearColor(0x000000, 0);
            
            // Create render targets with full window resolution like GitHub version
            mainRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            backRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            
            // Initialize uniforms
            uniforms = {
                uIorR: { value: 1.15 },
                uIorY: { value: 1.16 },
                uIorG: { value: 1.18 },
                uIorC: { value: 1.22 },
                uIorB: { value: 1.22 },
                uIorP: { value: 1.22 },
                uSaturation: { value: 1.01 },
                uChromaticAberration: { value: 0.14 },
                uRefractPower: { value: 0.35 },
                uFresnelPower: { value: 9.0 },
                uShininess: { value: 25.0 },
                uDiffuseness: { value: 0.2 },
                uLight: { value: new THREE.Vector3(-1.0, 1.0, 1.0) },
                winResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight).multiplyScalar(Math.min(window.devicePixelRatio, 2)) },
                uTexture: { value: null }
            };
            
            // Add comprehensive lighting setup
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Secondary directional light for fill
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-5, 3, 5);
            scene.add(fillLight);
            
            // Rim light for edge highlighting
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(0, -5, 5);
            scene.add(rimLight);
            
            // Point light for dynamic highlights
            const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
            pointLight.position.set(0, 0, 10);
            scene.add(pointLight);
            
            // Background plane removed - no longer needed
            
            // Create 3D text
            create3DText();
            
            // Load GLTF model
            loadBarModel();
            
            // Create glass cube
            createGlassCube();
            
            // Initialize OrbitControls
            initializeOrbitControls();
            
            // Add event listeners
            addEventListeners();
        }

        function degToRad(deg) {
            return deg * (Math.PI / 180);
        }

        // Create 3D text
        function create3DText() {
            
            const fontLoader = new THREE.FontLoader();
            
            // Load Outfit font (converted to Three.js typeface format)
            fontLoader.load(
                'https://raw.githubusercontent.com/gorillabiscuit/cerebral-webflow/master/fonts/Outfit_Regular.json',
                (font) => {
                    // Create text geometry
                    const textGeometry = new THREE.TextGeometry('cerebral', {
                        font: font,
                        size: 5, // Text size
                        height: 0.00001, // Text depth/extrusion
                        curveSegments: 12,
                        bevelEnabled: false,
                        // bevelThickness: 0.03,
                        // bevelSize: 0.02,
                        // bevelOffset: 0,
                        // bevelSegments: 5
                    });
                    
                    // Center the text geometry
                    textGeometry.computeBoundingBox();
                    const bbox = textGeometry.boundingBox;
                    
                    const centerOffsetX = -(bbox.max.x + bbox.min.x) / 2;
                    const centerOffsetY = -(bbox.max.y + bbox.min.y) / 2;
                    const centerOffsetZ = 0; // Force Z-centering to 0 to prevent depth artifacts
                    
                    // Create RED material for text (easy to see)
                    const textMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    
                    // Create text mesh
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.name = 'cerebralText'; // Add name for easy reference
                    
                    // Position text using constants + centering offsets
                    textMesh.position.set(
                        TEXT.position.x + centerOffsetX, 
                        TEXT.position.y + centerOffsetY, 
                        TEXT.position.z + centerOffsetZ
                    );
                    
                    // Add to scene
                    scene.add(textMesh);
                },
                undefined, // No progress callback needed
                (error) => {
                    console.error('Error loading font:', error);
                }
            );
        }

        // Load GLTF model
        function loadBarModel() {
            // Check if GLTFLoader is available
            if (typeof THREE.GLTFLoader === 'undefined') {
                console.warn('GLTFLoader not available, skipping bar model');
                return;
            }
            
            const gltfLoader = new THREE.GLTFLoader();
            
            // Load bar.glb model - toggle between local and GitHub CDN
            const modelUrl = USE_LOCAL_FILES 
                ? './models/bar.glb'  // Local file for fast iteration
                : 'https://raw.githubusercontent.com/gorillabiscuit/cerebral-webflow/master/models/bar.glb'; // GitHub CDN
            
            console.log('Loading bar model from:', USE_LOCAL_FILES ? 'LOCAL' : 'GITHUB CDN');
            gltfLoader.load(
                modelUrl,
                (gltf) => {
                    console.log('Bar model loaded successfully');
                    const barModel = gltf.scene;
                    
                    // üîß SOLUTION 1: Center the geometry itself (most robust approach)
                    const box = new THREE.Box3().setFromObject(barModel);
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // üîß THREE.JS R128: Apply centering transformation to ALL child geometries
                    console.log('=== R128 GEOMETRY CENTERING ===');
                    let geometriesProcessed = 0;
                    
                    barModel.traverse((child) => {
                        if (child.isMesh && child.geometry) {
                            console.log('Processing geometry:', child.geometry.type || 'Unknown');
                            
                            // r128 compatible geometry translation
                            if (typeof child.geometry.translate === 'function') {
                                child.geometry.translate(-center.x, -center.y, -center.z);
                                geometriesProcessed++;
                            } else {
                                console.warn('geometry.translate() not available for:', child.geometry.type);
                                // Fallback for r128 - manual vertex translation
                                if (child.geometry.attributes && child.geometry.attributes.position) {
                                    const positions = child.geometry.attributes.position.array;
                                    for (let i = 0; i < positions.length; i += 3) {
                                        positions[i] -= center.x;     // x
                                        positions[i + 1] -= center.y; // y  
                                        positions[i + 2] -= center.z; // z
                                    }
                                    child.geometry.attributes.position.needsUpdate = true;
                                    geometriesProcessed++;
                                }
                            }
                        }
                    });
                    
                    console.log('Geometries processed for centering:', geometriesProcessed);
                    
                    // Add XYZ axes helper at origin (model should now be truly centered here)
                    const axesHelper = new THREE.AxesHelper(1);
                    axesHelper.position.set(0, 0, 0);
                    barModel.add(axesHelper);
                    
                    // Apply model transformations normally - geometry is now truly centered
                    barModel.scale.set(BAR_MODEL.scale.x, BAR_MODEL.scale.y, BAR_MODEL.scale.z);
                    barModel.position.set(BAR_MODEL.position.x, BAR_MODEL.position.y, BAR_MODEL.position.z);
                    barModel.rotation.set(BAR_MODEL.rotation.x, BAR_MODEL.rotation.y, BAR_MODEL.rotation.z);
                    
                    // OrbitControls should target origin by default
                    if (controls) {
                        controls.target.set(0, 0, 0);
                        controls.update();
                    }
                    
                    // üîß FIX 2: Three.js r128 compatible camera direction fix
                    console.log('=== THREE.JS R128 CAMERA DIRECTION FIX ===');
                    console.log('Before fix - Camera position:', camera.position);
                    
                    // Check if clearViewOffset exists (r128 compatibility)
                    if (typeof camera.clearViewOffset === 'function') {
                        camera.clearViewOffset();
                        console.log('clearViewOffset() called successfully');
                    } else {
                        console.log('clearViewOffset() not available in this Three.js version');
                        // Manual view offset reset for older versions
                        if (camera.view) {
                            camera.view = null;
                        }
                    }
                    
                    // üîß DIRECT CAMERA FIX: Reset camera completely
                    console.log('=== DIRECT CAMERA RESET ===');
                    
                    // Reset camera position and rotation completely
                    camera.position.set(0, 0, 10);
                    camera.rotation.set(0, 0, 0);
                    camera.quaternion.set(0, 0, 0, 1);
                    
                    // Force camera to look at origin (multiple methods for r128)
                    camera.lookAt(0, 0, 0);
                    camera.updateMatrix();
                    camera.updateMatrixWorld(true);
                    camera.updateProjectionMatrix();
                    
                    // Verify the fix with simple direction check
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    console.log('After reset - Camera direction:', direction);
                    console.log('After reset - Direction should be (0, 0, -1)');
                    
                    // Test: Create a simple ray from camera to see where it points
                    const ray = new THREE.Ray(camera.position, direction);
                    const distanceToOrigin = ray.distanceToPoint(new THREE.Vector3(0, 0, 0));
                    console.log('Distance from camera ray to origin:', distanceToOrigin);
                    console.log('Distance should be near 0 if camera points at origin');
                    
                    // Make all materials in the model 50% transparent
                    barModel.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.transparent = true;
                            child.material.opacity = 0.5;
                        }
                    });
                    
                    // Add to scene
                    scene.add(barModel);
                    
                    // Optional: Add the model to the wrapper for mouse interactions
                    // wrapper.add(barModel);
                },
                (progress) => {
                    console.log('Loading bar model:', (progress.loaded / progress.total * 100) + '%');
                },
                (error) => {
                    console.error('Error loading bar model:', error);
                }
            );
        }

        // Create glass cube
        function createGlassCube() {
            // Create cube geometry
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            
            // üîç DEBUG: Check cube geometry centering
            geometry.computeBoundingBox();
            const cubeBox = geometry.boundingBox;
            const cubeCenter = new THREE.Vector3();
            cubeBox.getCenter(cubeCenter);
            
            console.log('=== GLASS CUBE CENTERING DEBUG ===');
            console.log('Cube geometry bounding box:', cubeBox);
            console.log('Cube geometry center:', cubeCenter);
            console.log('Cube center values:', cubeCenter.x, cubeCenter.y, cubeCenter.z);
            console.log('Is cube geometry centered?', 
                Math.abs(cubeCenter.x) < 0.001, 
                Math.abs(cubeCenter.y) < 0.001, 
                Math.abs(cubeCenter.z) < 0.001
            );
            
            // Create glass shader material
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: uniforms,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            
            // Check for shader compilation errors (keep error logging)
            if (material.program && material.program.error) {
                console.error('Shader compilation error:', material.program.error);
            }
            
            // Create mesh
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, 0); // Ensure mesh is at origin within wrapper
            
            // Create wrapper group
            wrapper = new THREE.Group();
            wrapper.add(mesh);
            
            // Scale the wrapper
            wrapper.scale.set(3, 3, 3);
            
            // Move cube forward towards camera by 2 units
            wrapper.position.set(0, 0, 2);
            
            // üîç DEBUG: Check final wrapper world position
            const wrapperBox = new THREE.Box3().setFromObject(wrapper);
            const wrapperCenter = wrapperBox.getCenter(new THREE.Vector3());
            console.log('Glass cube wrapper center after transforms:', wrapperCenter);
            console.log('Wrapper position:', wrapper.position);
            console.log('Wrapper scale:', wrapper.scale);
            
            // Add axes helper to wrapper for visual reference
            const cubeAxes = new THREE.AxesHelper(2);
            cubeAxes.position.set(0, 0, 0);
            wrapper.add(cubeAxes);
            
            // Add to scene
            scene.add(wrapper);
            
            isModelReady = true;
        }


        // Initialize OrbitControls
        function initializeOrbitControls() {
            // Check if OrbitControls should be enabled
            if (!ENABLE_ORBIT_CONTROLS) {
                console.log('OrbitControls disabled by ENABLE_ORBIT_CONTROLS setting');
                return;
            }
            
            // Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('OrbitControls not available');
                return;
            }
            
            controls = new THREE.OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            controls.autoRotate = false;
            controls.autoRotateSpeed = 2.0;
            
            console.log('OrbitControls initialized');
        }

        // Add event listeners
        function addEventListeners() {
            // Mouse move handler for cube rotation
            window.addEventListener('mousemove', (e) => {
                // Update mouse position for cube rotation
                mouse.x = e.clientX / window.innerWidth - 0.5;
                mouse.y = e.clientY / window.innerHeight - 0.5;
                
                // Initialize lastMousePos if it hasn't been set yet
                if (lastMousePos.x === 0 && lastMousePos.y === 0) {
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    return;
                }
                
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                // Add mouse movement to influence (normalized to screen size)
                mouseInfluence.x += deltaX / window.innerWidth * 2.0;
                mouseInfluence.y += deltaY / window.innerHeight * 2.0;
                
                lastMousePos.x = e.clientX;
                lastMousePos.y = e.clientY;
            });
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        // Window resize handler
        function onWindowResize() {
            // üîß FIX 1: Use proper DPI-aware resize function
            resizeCanvasToDisplaySize();
            
            // Update render targets with new size
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            const width = canvas.clientWidth * pixelRatio;
            const height = canvas.clientHeight * pixelRatio;
            
            mainRenderTarget.setSize(width, height);
            backRenderTarget.setSize(width, height);
            
            // Update uniforms
            uniforms.winResolution.value.set(canvas.clientWidth, canvas.clientHeight).multiplyScalar(pixelRatio);
            
            console.log('Window resized - render targets updated to:', width, 'x', height);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update OrbitControls if available
            if (controls) {
                controls.update();
            }
            
            // Rotate cube based on mouse position using GSAP
            if (wrapper && isModelReady) {
                gsap.to(wrapper.rotation, {
                    x: mouse.y * 0.5,
                    y: mouse.x * 0.5,
                    duration: 0.8,
                    ease: "power2.out",
                    overwrite: "auto"
                });
            }
            
            // Glass refraction rendering
            if (mesh) {
                mesh.visible = false;
                
                // Back side render
                renderer.setRenderTarget(backRenderTarget);
                renderer.render(scene, camera);
                
                mesh.material.uniforms.uTexture.value = backRenderTarget.texture;
                mesh.material.side = THREE.BackSide;
                
                mesh.visible = true;
                
                // Front side render
                renderer.setRenderTarget(mainRenderTarget);
                renderer.render(scene, camera);
                
                mesh.material.uniforms.uTexture.value = mainRenderTarget.texture;
                mesh.material.side = THREE.FrontSide;
                
                renderer.setRenderTarget(null);
            }
            
            renderer.render(scene, camera);
        }

        // Initialize when everything is loaded
        window.addEventListener('load', () => {
            console.log('All libraries loaded, initializing scene...');
            console.log('THREE available:', typeof THREE !== 'undefined');
            console.log('GSAP available:', typeof gsap !== 'undefined');
            
            if (typeof THREE === 'undefined') {
                console.error('THREE.js failed to load! Check CDN URLs');
                return;
            }
            
            console.log('THREE.REVISION:', THREE.REVISION);
            console.log('THREE.FontLoader available:', typeof THREE.FontLoader !== 'undefined');
            console.log('THREE.TextGeometry available:', typeof THREE.TextGeometry !== 'undefined');
            console.log('THREE.OrbitControls available:', typeof THREE.OrbitControls !== 'undefined');
            console.log('THREE.GLTFLoader available:', typeof THREE.GLTFLoader !== 'undefined');
            init();
            animate();
        });
</script>
<!-- ============================================= -->
<!-- END WEBFLOW CODE BLOCK -->
<!-- ============================================= -->