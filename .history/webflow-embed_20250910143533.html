<!DOCTYPE html>
<html>
<head>
    <title>NFTfi Glass Shader - Webflow Compatible</title>
    <meta charset="UTF-8" />
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: white;
            background-color: #271E23;
        }

        /* Three.js Canvas - Background Layer */
        #webgl {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            pointer-events: auto;
        }

        /* Controls Panel Styles */
        .controls-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(10px);
            max-width: 280px;
            position: fixed;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            max-height: 75vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .controls-panel h3 {
            color: #F2F2F2;
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
        }

        /* Accordion Styles */
        .accordion-section {
            margin-bottom: 8px;
        }

        .accordion-section:last-child {
            margin-bottom: 0;
        }

        .accordion-header {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #F2F2F2;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .accordion-header:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .accordion-header:active {
            background: rgba(255, 255, 255, 0.2);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .accordion-content.expanded {
            max-height: 500px;
        }

        .chevron {
            transition: transform 0.3s ease;
            color: #F2F2F2;
        }

        .accordion-header.expanded .chevron {
            transform: rotate(180deg);
        }

        .control-group {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            color: #F2F2F2;
            font-size: 11px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            gap: 6px;
        }

        .control-row label {
            color: #F2F2F2;
            font-size: 10px;
            font-weight: 400;
            margin: 0;
            min-width: 70px;
        }

        .control-slider {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #F2F2F2;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #F2F2F2;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .vector-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            color: #F2F2F2;
            font-size: 11px;
            font-weight: 400;
            opacity: 0.8;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls-panel {
                position: fixed;
                left: 10px;
                right: 10px;
                top: 10px;
                transform: none;
                max-width: none;
                max-height: 40vh;
                margin: 0;
            }
            
            .control-row {
                flex-direction: column;
                align-items: stretch;
                gap: 5px;
            }
            
            .control-row label {
                min-width: auto;
            }
        }

        /* Content sections for demonstration */
        section {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body>
    <main>
        <section>
            <h2>NFTfi Glass Shader Demo</h2>
        </section>
    </main>

    <!-- WEBFLOW EMBED START -->
    <canvas id="webgl"></canvas>
    
    <!-- UI Controls Panel -->
    <div class="controls-panel">
        <h3>Shader Controls</h3>
        
        <!-- Light Controls -->
        <div class="accordion-section">
            <button class="accordion-header">
                <span>Light Direction</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 12 12">
                    <path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </button>
            <div class="accordion-content">
                <div class="control-group">
                    <div class="vector-controls">
                        <input type="range" id="lightX" min="-2" max="2" step="0.1" value="-1.0" class="control-slider">
                        <input type="range" id="lightY" min="-2" max="2" step="0.1" value="1.0" class="control-slider">
                        <input type="range" id="lightZ" min="-2" max="2" step="0.1" value="1.0" class="control-slider">
                        <span class="control-label">X: <span id="lightXValue">-1.0</span></span>
                        <span class="control-label">Y: <span id="lightYValue">1.0</span></span>
                        <span class="control-label">Z: <span id="lightZValue">1.0</span></span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Material Controls -->
        <div class="accordion-section">
            <button class="accordion-header">
                <span>Material Properties</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 12 12">
                    <path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </button>
            <div class="accordion-content">
                <div class="control-group">
                    <div class="control-row">
                        <label>Diffuseness: <span id="diffusenessValue">0.2</span></label>
                        <input type="range" id="diffuseness" min="0" max="1" step="0.01" value="0.2" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Shininess: <span id="shininessValue">25.0</span></label>
                        <input type="range" id="shininess" min="1" max="100" step="0.1" value="25.0" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Fresnel Power: <span id="fresnelPowerValue">9.0</span></label>
                        <input type="range" id="fresnelPower" min="0" max="20" step="0.1" value="9.0" class="control-slider">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- IOR Controls -->
        <div class="accordion-section">
            <button class="accordion-header">
                <span>Index of Refraction (IOR)</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 12 12">
                    <path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </button>
            <div class="accordion-content">
                <div class="control-group">
                    <div class="control-row">
                        <label>Red: <span id="iorRValue">1.15</span></label>
                        <input type="range" id="iorR" min="1.0" max="2.333" step="0.001" value="1.15" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Yellow: <span id="iorYValue">1.16</span></label>
                        <input type="range" id="iorY" min="1.0" max="2.333" step="0.001" value="1.16" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Green: <span id="iorGValue">1.18</span></label>
                        <input type="range" id="iorG" min="1.0" max="2.333" step="0.001" value="1.18" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Cyan: <span id="iorCValue">1.22</span></label>
                        <input type="range" id="iorC" min="1.0" max="2.333" step="0.001" value="1.22" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Blue: <span id="iorBValue">1.22</span></label>
                        <input type="range" id="iorB" min="1.0" max="2.333" step="0.001" value="1.22" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Purple: <span id="iorPValue">1.22</span></label>
                        <input type="range" id="iorP" min="1.0" max="2.333" step="0.001" value="1.22" class="control-slider">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Effect Controls -->
        <div class="accordion-section">
            <button class="accordion-header">
                <span>Effects</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 12 12">
                    <path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </button>
            <div class="accordion-content">
                <div class="control-group">
                    <div class="control-row">
                        <label>Saturation: <span id="saturationValue">1.01</span></label>
                        <input type="range" id="saturation" min="1" max="1.25" step="0.01" value="1.01" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Chromatic Aberration: <span id="chromaticAberrationValue">0.14</span></label>
                        <input type="range" id="chromaticAberration" min="0" max="1.5" step="0.01" value="0.14" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Refraction Power: <span id="refractionValue">0.35</span></label>
                        <input type="range" id="refraction" min="0" max="1" step="0.01" value="0.35" class="control-slider">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Camera Controls -->
        <div class="accordion-section">
            <button class="accordion-header">
                <span>Camera</span>
                <svg class="chevron" width="12" height="12" viewBox="0 0 12 12">
                    <path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="2" fill="none"/>
                </svg>
            </button>
            <div class="accordion-content">
                <div class="control-group">
                    <div class="control-row">
                        <label>X Position: <span id="cameraXValue">0.0</span></label>
                        <input type="range" id="cameraX" min="-10" max="10" step="0.1" value="0.0" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Y Position: <span id="cameraYValue">0.0</span></label>
                        <input type="range" id="cameraY" min="-10" max="10" step="0.1" value="0.0" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Z Position: <span id="cameraZValue">33.6</span></label>
                        <input type="range" id="cameraZ" min="1" max="100" step="0.1" value="33.6" class="control-slider">
                    </div>
                    <div class="control-row">
                        <label>Field of View: <span id="cameraFOVValue">75</span></label>
                        <input type="range" id="cameraFOV" min="10" max="120" step="1" value="75" class="control-slider">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.178.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.178.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from "three";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

        console.log('Three.js Glass Shader Scene initialized');

        // Scene variables
        let scene, camera, renderer, canvas;
        let mesh, wrapper;
        let isModelReady = false;
        let mainRenderTarget, backRenderTarget;
        let uniforms;
        let mouseInfluence = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };

        // Shader code
        const vertexShader = `
        varying vec3 worldNormal;
        varying vec3 eyeVector;

        void main() {
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vec4 mvPosition = viewMatrix * worldPos;

          gl_Position = projectionMatrix * mvPosition;

          worldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
          eyeVector = normalize(worldPos.xyz - cameraPosition);
        }
        `;

        const fragmentShader = `
        uniform float uIorR;
        uniform float uIorY;
        uniform float uIorG;
        uniform float uIorC;
        uniform float uIorB;
        uniform float uIorP;

        uniform float uSaturation;
        uniform float uChromaticAberration;
        uniform float uRefractPower;
        uniform float uFresnelPower;
        uniform float uShininess;
        uniform float uDiffuseness;
        uniform vec3 uLight;

        uniform vec2 winResolution;
        uniform sampler2D uTexture;

        varying vec3 worldNormal;
        varying vec3 eyeVector;

        vec3 sat(vec3 rgb, float adjustment) {
          const vec3 W = vec3(0.2125, 0.7154, 0.0721);
          vec3 intensity = vec3(dot(rgb, W));
          return mix(intensity, rgb, adjustment);
        }

        float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {
          float fresnelFactor = abs(dot(eyeVector, worldNormal));
          float inversefresnelFactor = 1.0 - fresnelFactor;
          
          return pow(inversefresnelFactor, power);
        }

        float specular(vec3 light, float shininess, float diffuseness) {
          vec3 normal = worldNormal;
          vec3 lightVector = normalize(-light);
          vec3 halfVector = normalize(eyeVector + lightVector);

          float NdotL = dot(normal, lightVector);
          float NdotH =  dot(normal, halfVector);
          float kDiffuse = max(0.0, NdotL);
          float NdotH2 = NdotH * NdotH;

          float kSpecular = pow(NdotH2, shininess);
          return  kSpecular + kDiffuse * diffuseness;
        }

        const int LOOP = 16;

        void main() {
          float iorRatioRed = 1.0/uIorR;
          float iorRatioGreen = 1.0/uIorG;
          float iorRatioBlue = 1.0/uIorB;

          vec2 uv = gl_FragCoord.xy / winResolution.xy;
          vec3 normal = worldNormal;
          vec3 color = vec3(0.0);

          for ( int i = 0; i < LOOP; i ++ ) {
            float slide = float(i) / float(LOOP) * 0.1;

            vec3 refractVecR = refract(eyeVector, normal,(1.0/uIorR));
            vec3 refractVecY = refract(eyeVector, normal, (1.0/uIorY));
            vec3 refractVecG = refract(eyeVector, normal, (1.0/uIorG));
            vec3 refractVecC = refract(eyeVector, normal, (1.0/uIorC));
            vec3 refractVecB = refract(eyeVector, normal, (1.0/uIorB));
            vec3 refractVecP = refract(eyeVector, normal, (1.0/uIorP));

            float r = texture2D(uTexture, uv + refractVecR.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;

            float y = (texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;

            float g = texture2D(uTexture, uv + refractVecG.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;

            float c = (texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;
                  
            float b = texture2D(uTexture, uv + refractVecB.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;

            float p = (texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;

            float R = r + (2.0*p + 2.0*y - c)/3.0;
            float G = g + (2.0*y + 2.0*c - p)/3.0;
            float B = b + (2.0*c + 2.0*p - y)/3.0;

            color.r += R;
            color.g += G;
            color.b += B;

            color = sat(color, uSaturation);
          }

          // Divide by the number of layers to normalize colors
          color /= float( LOOP );

          // Specular
          float specularLight = specular(uLight, uShininess, uDiffuseness);
          color += specularLight;

          // Fresnel
          float f = fresnel(eyeVector, normal, uFresnelPower);
          color.rgb += f * vec3(1.0);

          gl_FragColor = vec4(color, 1.0);
        }
        `;

        // Initialize Three.js scene
        function init() {
            console.log('Initializing Three.js scene...');
            
            // Get canvas
            canvas = document.getElementById('webgl');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = null; // Transparent background
            
            // Create camera with full screen aspect ratio
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 33.6);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            
            // Create render targets
            mainRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            backRenderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            
            // Initialize uniforms
            uniforms = {
                uIorR: { value: 1.15 },
                uIorY: { value: 1.16 },
                uIorG: { value: 1.18 },
                uIorC: { value: 1.22 },
                uIorB: { value: 1.22 },
                uIorP: { value: 1.22 },
                uSaturation: { value: 1.01 },
                uChromaticAberration: { value: 0.14 },
                uRefractPower: { value: 0.35 },
                uFresnelPower: { value: 9.0 },
                uShininess: { value: 25.0 },
                uDiffuseness: { value: 0.2 },
                uLight: { value: new THREE.Vector3(-1.0, 1.0, 1.0) },
                winResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight).multiplyScalar(Math.min(window.devicePixelRatio, 2)) },
                uTexture: { value: null }
            };
            
            // Add lighting setup
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-5, 3, 5);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(0, -5, 5);
            scene.add(rimLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
            pointLight.position.set(0, 0, 10);
            scene.add(pointLight);
            
            // Create background geometry for refraction
            createBackgroundGeometry();
            
            // Load GLTF model or create fallback
            loadModel();
            
            // Add event listeners
            addEventListeners();
        }

        // Create background geometry for refraction effects
        function createBackgroundGeometry() {
            const backgroundGroup = new THREE.Group();
            backgroundGroup.visible = true;
            scene.add(backgroundGroup);
            
            // Add plane with texture - NOTE: You'll need to host this image externally for Webflow
            const textureLoader = new THREE.TextureLoader();
            // Replace with your hosted image URL
            const headerTexture = textureLoader.load('https://your-domain.com/images/header.png');
            
            const planeScale = 1;
            const width = 20 * planeScale;
            const height = width * (591 / 1325);
            const planeGeometry = new THREE.PlaneGeometry(width, height);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                map: headerTexture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.set(-5.1, 0, -5.0);
            scene.add(plane);
        }

        // Load GLTF model
        function loadModel() {
            console.log('Loading NFTfi logo model...');
            
            const loader = new GLTFLoader();
            
            // NOTE: You'll need to host this model externally for Webflow
            loader.load('https://your-domain.com/models/nftfi_logo.glb', (gltf) => {
                console.log('Model loaded:', gltf);
                
                const box = new THREE.Box3().setFromObject(gltf.scene);
                const center = new THREE.Vector3();
                const size = new THREE.Vector3();
                box.getCenter(center);
                box.getSize(size);
                
                gltf.scene.traverse((child) => {
                    if (child.isMesh) {
                        mesh = child;
                        
                        if (child.geometry) {
                            child.geometry.computeVertexNormals();
                        }
                        
                        child.material = new THREE.ShaderMaterial({
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            uniforms: uniforms,
                            side: THREE.DoubleSide
                        });
                    }
                });
                
                wrapper = new THREE.Group();
                gltf.scene.position.set(-center.x, -center.y, -center.z);
                wrapper.add(gltf.scene);
                wrapper.scale.set(3, 3, 3);
                scene.add(wrapper);
                
                isModelReady = true;
                console.log('NFTfi logo ready for animation');
                
            }, (progress) => {
                console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
            }, (error) => {
                console.error('Error loading model:', error);
                createFallbackGeometry();
            });
        }

        // Fallback geometry if model loading fails
        function createFallbackGeometry() {
            console.log('Creating fallback geometry...');
            
            const geometry = new THREE.IcosahedronGeometry(2, 4);
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: uniforms,
                side: THREE.DoubleSide
            });
            
            mesh = new THREE.Mesh(geometry, material);
            wrapper = new THREE.Group();
            wrapper.add(mesh);
            wrapper.scale.set(3, 3, 3);
            scene.add(wrapper);
            
            isModelReady = true;
            console.log('Fallback geometry ready for animation');
        }

        // Add event listeners
        function addEventListeners() {
            // Mouse move handler
            window.addEventListener('mousemove', (e) => {
                if (lastMousePos.x === 0 && lastMousePos.y === 0) {
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    return;
                }
                
                const deltaX = e.clientX - lastMousePos.x;
                const deltaY = e.clientY - lastMousePos.y;
                
                mouseInfluence.x += deltaX / window.innerWidth * 2.0;
                mouseInfluence.y += deltaY / window.innerHeight * 2.0;
                
                lastMousePos.x = e.clientX;
                lastMousePos.y = e.clientY;
            });
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            mainRenderTarget.setSize(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            backRenderTarget.setSize(
                window.innerWidth * Math.min(window.devicePixelRatio, 2),
                window.innerHeight * Math.min(window.devicePixelRatio, 2)
            );
            
            uniforms.winResolution.value.set(window.innerWidth, window.innerHeight).multiplyScalar(Math.min(window.devicePixelRatio, 2));
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (wrapper && isModelReady) {
                const time = Date.now() * 0.001;
                
                mouseInfluence.x *= 0.98;
                mouseInfluence.y *= 0.98;
                
                const xRate = 0.2 + Math.sin(time * 0.1) * 0.15;
                wrapper.rotation.x += xRate * 0.02 + mouseInfluence.y * 0.05;
                
                const yRate = 0.3 + Math.cos(time * 0.08) * 0.2;
                wrapper.rotation.y += yRate * 0.02 + mouseInfluence.x * 0.05;
                
                const zRate = 0.15 + Math.sin(time * 0.12) * 0.1;
                wrapper.rotation.z += zRate * 0.02;
            }
            
            // Glass refraction rendering
            if (mesh) {
                mesh.visible = false;
                
                renderer.setRenderTarget(backRenderTarget);
                renderer.render(scene, camera);
                
                mesh.material.uniforms.uTexture.value = backRenderTarget.texture;
                mesh.material.side = THREE.BackSide;
                
                mesh.visible = true;
                
                renderer.setRenderTarget(mainRenderTarget);
                renderer.render(scene, camera);
                
                mesh.material.uniforms.uTexture.value = mainRenderTarget.texture;
                mesh.material.side = THREE.FrontSide;
                
                renderer.setRenderTarget(null);
            }
            
            renderer.render(scene, camera);
        }

        // Initialize controls
        function initializeControls() {
            initializeAccordion();
            
            // Light controls
            document.getElementById('lightX').addEventListener('input', updateLight);
            document.getElementById('lightY').addEventListener('input', updateLight);
            document.getElementById('lightZ').addEventListener('input', updateLight);
            
            // Material controls
            document.getElementById('diffuseness').addEventListener('input', updateMaterial);
            document.getElementById('shininess').addEventListener('input', updateMaterial);
            document.getElementById('fresnelPower').addEventListener('input', updateMaterial);
            
            // IOR controls
            document.getElementById('iorR').addEventListener('input', updateIOR);
            document.getElementById('iorY').addEventListener('input', updateIOR);
            document.getElementById('iorG').addEventListener('input', updateIOR);
            document.getElementById('iorC').addEventListener('input', updateIOR);
            document.getElementById('iorB').addEventListener('input', updateIOR);
            document.getElementById('iorP').addEventListener('input', updateIOR);
            
            // Effect controls
            document.getElementById('saturation').addEventListener('input', updateEffects);
            document.getElementById('chromaticAberration').addEventListener('input', updateEffects);
            document.getElementById('refraction').addEventListener('input', updateEffects);
            
            // Camera controls
            document.getElementById('cameraX').addEventListener('input', updateCamera);
            document.getElementById('cameraY').addEventListener('input', updateCamera);
            document.getElementById('cameraZ').addEventListener('input', updateCamera);
            document.getElementById('cameraFOV').addEventListener('input', updateCamera);
            
            if (camera) {
                document.getElementById('cameraX').value = camera.position.x;
                document.getElementById('cameraY').value = camera.position.y;
                document.getElementById('cameraZ').value = camera.position.z;
                document.getElementById('cameraFOV').value = camera.fov;
                updateCamera();
            }
        }

        // Initialize accordion functionality
        function initializeAccordion() {
            const headers = document.querySelectorAll('.accordion-header');
            
            headers.forEach(header => {
                header.addEventListener('click', toggleAccordionSection);
            });
        }

        // Toggle accordion section
        function toggleAccordionSection(event) {
            const header = event.currentTarget;
            const content = header.nextElementSibling;
            const isExpanded = header.classList.contains('expanded');
            
            if (isExpanded) {
                header.classList.remove('expanded');
                content.classList.remove('expanded');
            } else {
                header.classList.add('expanded');
                content.classList.add('expanded');
            }
        }

        function updateLight() {
            const x = parseFloat(document.getElementById('lightX').value);
            const y = parseFloat(document.getElementById('lightY').value);
            const z = parseFloat(document.getElementById('lightZ').value);
            
            document.getElementById('lightXValue').textContent = x.toFixed(1);
            document.getElementById('lightYValue').textContent = y.toFixed(1);
            document.getElementById('lightZValue').textContent = z.toFixed(1);
            
            if (uniforms && uniforms.uLight) {
                uniforms.uLight.value.set(x, y, z);
            }
        }

        function updateMaterial() {
            const diffuseness = parseFloat(document.getElementById('diffuseness').value);
            const shininess = parseFloat(document.getElementById('shininess').value);
            const fresnelPower = parseFloat(document.getElementById('fresnelPower').value);
            
            document.getElementById('diffusenessValue').textContent = diffuseness.toFixed(2);
            document.getElementById('shininessValue').textContent = shininess.toFixed(1);
            document.getElementById('fresnelPowerValue').textContent = fresnelPower.toFixed(1);
            
            if (uniforms) {
                if (uniforms.uDiffuseness) uniforms.uDiffuseness.value = diffuseness;
                if (uniforms.uShininess) uniforms.uShininess.value = shininess;
                if (uniforms.uFresnelPower) uniforms.uFresnelPower.value = fresnelPower;
            }
        }

        function updateIOR() {
            const iorR = parseFloat(document.getElementById('iorR').value);
            const iorY = parseFloat(document.getElementById('iorY').value);
            const iorG = parseFloat(document.getElementById('iorG').value);
            const iorC = parseFloat(document.getElementById('iorC').value);
            const iorB = parseFloat(document.getElementById('iorB').value);
            const iorP = parseFloat(document.getElementById('iorP').value);
            
            document.getElementById('iorRValue').textContent = iorR.toFixed(3);
            document.getElementById('iorYValue').textContent = iorY.toFixed(3);
            document.getElementById('iorGValue').textContent = iorG.toFixed(3);
            document.getElementById('iorCValue').textContent = iorC.toFixed(3);
            document.getElementById('iorBValue').textContent = iorB.toFixed(3);
            document.getElementById('iorPValue').textContent = iorP.toFixed(3);
            
            if (uniforms) {
                if (uniforms.uIorR) uniforms.uIorR.value = iorR;
                if (uniforms.uIorY) uniforms.uIorY.value = iorY;
                if (uniforms.uIorG) uniforms.uIorG.value = iorG;
                if (uniforms.uIorC) uniforms.uIorC.value = iorC;
                if (uniforms.uIorB) uniforms.uIorB.value = iorB;
                if (uniforms.uIorP) uniforms.uIorP.value = iorP;
            }
        }

        function updateEffects() {
            const saturation = parseFloat(document.getElementById('saturation').value);
            const chromaticAberration = parseFloat(document.getElementById('chromaticAberration').value);
            const refraction = parseFloat(document.getElementById('refraction').value);
            
            document.getElementById('saturationValue').textContent = saturation.toFixed(2);
            document.getElementById('chromaticAberrationValue').textContent = chromaticAberration.toFixed(2);
            document.getElementById('refractionValue').textContent = refraction.toFixed(2);
            
            if (uniforms) {
                if (uniforms.uSaturation) uniforms.uSaturation.value = saturation;
                if (uniforms.uChromaticAberration) uniforms.uChromaticAberration.value = chromaticAberration;
                if (uniforms.uRefractPower) uniforms.uRefractPower.value = refraction;
            }
        }

        function updateCamera() {
            const x = parseFloat(document.getElementById('cameraX').value);
            const y = parseFloat(document.getElementById('cameraY').value);
            const z = parseFloat(document.getElementById('cameraZ').value);
            const fovSlider = parseFloat(document.getElementById('cameraFOV').value);
            
            document.getElementById('cameraXValue').textContent = x.toFixed(1);
            document.getElementById('cameraYValue').textContent = y.toFixed(1);
            document.getElementById('cameraZValue').textContent = z.toFixed(1);
            document.getElementById('cameraFOVValue').textContent = fovSlider.toFixed(0);
            
            if (camera) {
                camera.position.set(x, y, z);
                camera.fov = fovSlider;
                camera.updateProjectionMatrix();
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, ready to initialize Three.js scene');
            init();
            animate();
            setTimeout(initializeControls, 1000);
        });
    </script>
    <!-- WEBFLOW EMBED END -->
</body>
</html>
