<!DOCTYPE html>
<html>
  <head>
    <title>Three.js Glass Shader - Webflow Ready</title>
    <meta charset="UTF-8" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        background-color: #271E23;
      }

      #webgl {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: -1;
        width: 100vw;
        height: 100vh;
      }

    </style>
  </head>
  <body>

    <!-- WEBFLOW EMBED START -->
    <canvas id="webgl"></canvas>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.178.0/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";

      // Scene variables
      let scene, camera, renderer, canvas;
      let mesh, wrapper;
      let isModelReady = false;
      let mainRenderTarget, backRenderTarget;
      let uniforms;
      let mouseInfluence = { x: 0, y: 0 };
      let lastMousePos = { x: 0, y: 0 };

      // Glass shader code
      const vertexShader = `
        varying vec3 worldNormal;
        varying vec3 eyeVector;

        void main() {
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vec4 mvPosition = viewMatrix * worldPos;

          gl_Position = projectionMatrix * mvPosition;

          worldNormal = normalize(modelMatrix * vec4(normal, 0.0)).xyz;
          eyeVector = normalize(worldPos.xyz - cameraPosition);
        }
      `;

      const fragmentShader = `
        uniform float uIorR;
        uniform float uIorY;
        uniform float uIorG;
        uniform float uIorC;
        uniform float uIorB;
        uniform float uIorP;

        uniform float uSaturation;
        uniform float uChromaticAberration;
        uniform float uRefractPower;
        uniform float uFresnelPower;
        uniform float uShininess;
        uniform float uDiffuseness;
        uniform vec3 uLight;

        uniform vec2 winResolution;
        uniform sampler2D uTexture;

        varying vec3 worldNormal;
        varying vec3 eyeVector;

        vec3 sat(vec3 rgb, float adjustment) {
          const vec3 W = vec3(0.2125, 0.7154, 0.0721);
          vec3 intensity = vec3(dot(rgb, W));
          return mix(intensity, rgb, adjustment);
        }

        float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {
          float fresnelFactor = abs(dot(eyeVector, worldNormal));
          float inversefresnelFactor = 1.0 - fresnelFactor;
          
          return pow(inversefresnelFactor, power);
        }

        float specular(vec3 light, float shininess, float diffuseness) {
          vec3 normal = worldNormal;
          vec3 lightVector = normalize(-light);
          vec3 halfVector = normalize(eyeVector + lightVector);

          float NdotL = dot(normal, lightVector);
          float NdotH =  dot(normal, halfVector);
          float kDiffuse = max(0.0, NdotL);
          float NdotH2 = NdotH * NdotH;

          float kSpecular = pow(NdotH2, shininess);
          return  kSpecular + kDiffuse * diffuseness;
        }

        const int LOOP = 16;

        void main() {
          vec2 uv = gl_FragCoord.xy / winResolution.xy;
          vec3 normal = worldNormal;
          vec3 color = vec3(0.0);

          for ( int i = 0; i < LOOP; i ++ ) {
            float slide = float(i) / float(LOOP) * 0.1;

            vec3 refractVecR = refract(eyeVector, normal,(1.0/uIorR));
            vec3 refractVecY = refract(eyeVector, normal, (1.0/uIorY));
            vec3 refractVecG = refract(eyeVector, normal, (1.0/uIorG));
            vec3 refractVecC = refract(eyeVector, normal, (1.0/uIorC));
            vec3 refractVecB = refract(eyeVector, normal, (1.0/uIorB));
            vec3 refractVecP = refract(eyeVector, normal, (1.0/uIorP));

            float r = texture2D(uTexture, uv + refractVecR.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;

            float y = (texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -
                        texture2D(uTexture, uv + refractVecY.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;

            float g = texture2D(uTexture, uv + refractVecG.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;

            float c = (texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -
                        texture2D(uTexture, uv + refractVecC.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;
                  
            float b = texture2D(uTexture, uv + refractVecB.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;

            float p = (texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -
                        texture2D(uTexture, uv + refractVecP.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;

            float R = r + (2.0*p + 2.0*y - c)/3.0;
            float G = g + (2.0*y + 2.0*c - p)/3.0;
            float B = b + (2.0*c + 2.0*p - y)/3.0;

            color.r += R;
            color.g += G;
            color.b += B;

            color = sat(color, uSaturation);
          }

          // Divide by the number of layers to normalize colors
          color /= float( LOOP );

          // Specular
          float specularLight = specular(uLight, uShininess, uDiffuseness);
          color += specularLight;

          // Fresnel
          float f = fresnel(eyeVector, normal, uFresnelPower);
          color.rgb += f * vec3(1.0);

          gl_FragColor = vec4(color, 1.0);
        }
      `;

      // Initialize Three.js scene
      function init() {
        console.log('Initializing Webflow Three.js scene...');
        
        // Get canvas
        canvas = document.getElementById('webgl');
        
        // Create scene
        scene = new THREE.Scene();
        scene.background = null; // Transparent background
        
        // Create camera with full screen aspect ratio
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ 
          canvas: canvas,
          alpha: true,
          antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        
        // Create render targets
        mainRenderTarget = new THREE.WebGLRenderTarget(
          window.innerWidth * Math.min(window.devicePixelRatio, 2),
          window.innerHeight * Math.min(window.devicePixelRatio, 2)
        );
        backRenderTarget = new THREE.WebGLRenderTarget(
          window.innerWidth * Math.min(window.devicePixelRatio, 2),
          window.innerHeight * Math.min(window.devicePixelRatio, 2)
        );
        
        // Initialize uniforms
        uniforms = {
          uIorR: { value: 1.15 },
          uIorY: { value: 1.16 },
          uIorG: { value: 1.18 },
          uIorC: { value: 1.22 },
          uIorB: { value: 1.22 },
          uIorP: { value: 1.22 },
          uSaturation: { value: 1.01 },
          uChromaticAberration: { value: 0.14 },
          uRefractPower: { value: 0.35 },
          uFresnelPower: { value: 9.0 },
          uShininess: { value: 25.0 },
          uDiffuseness: { value: 0.2 },
          uLight: { value: new THREE.Vector3(-1.0, 1.0, 1.0) },
          winResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight).multiplyScalar(Math.min(window.devicePixelRatio, 2)) },
          uTexture: { value: null }
        };
        
        // Add comprehensive lighting setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-5, 3, 5);
        scene.add(fillLight);
        
        // Create background geometry for refraction
        createBackgroundGeometry();
        
        // Create glass cube
        createGlassCube();
        
        // Add event listeners
        addEventListeners();
      }

      // Create background geometry for refraction effects
      function createBackgroundGeometry() {
        // Add plane with a simple gradient texture instead of loading external image
        const canvas2D = document.createElement('canvas');
        canvas2D.width = 1024;
        canvas2D.height = 512;
        const context = canvas2D.getContext('2d');
        
        // Create gradient background
        const gradient = context.createLinearGradient(0, 0, canvas2D.width, canvas2D.height);
        gradient.addColorStop(0, '#FF6B6B');
        gradient.addColorStop(0.5, '#4ECDC4');
        gradient.addColorStop(1, '#45B7D1');
        
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas2D.width, canvas2D.height);
        
        const texture = new THREE.CanvasTexture(canvas2D);
        
        // Create plane geometry
        const planeGeometry = new THREE.PlaneGeometry(20, 10);
        const planeMaterial = new THREE.MeshBasicMaterial({ 
          map: texture,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide
        });
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.set(0, 0, -5);
        scene.add(plane);
      }

      // Create glass cube with shader material
      function createGlassCube() {
        console.log('Creating glass cube...');
        
        // Create cube geometry
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        
        // Create glass shader material
        const material = new THREE.ShaderMaterial({
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          uniforms: uniforms,
          side: THREE.DoubleSide
        });
        
        mesh = new THREE.Mesh(geometry, material);
        
        // Create wrapper group
        wrapper = new THREE.Group();
        wrapper.add(mesh);
        wrapper.scale.set(1, 1, 1);
        
        // Add to scene
        scene.add(wrapper);
        
        isModelReady = true;
        console.log('Glass cube ready for animation');
      }

      // Add event listeners
      function addEventListeners() {
        // Mouse move handler
        window.addEventListener('mousemove', (e) => {
          if (lastMousePos.x === 0 && lastMousePos.y === 0) {
            lastMousePos.x = e.clientX;
            lastMousePos.y = e.clientY;
            return;
          }
          
          const deltaX = e.clientX - lastMousePos.x;
          const deltaY = e.clientY - lastMousePos.y;
          
          mouseInfluence.x += deltaX / window.innerWidth * 2.0;
          mouseInfluence.y += deltaY / window.innerHeight * 2.0;
          
          lastMousePos.x = e.clientX;
          lastMousePos.y = e.clientY;
        });
        
        // Window resize handler
        window.addEventListener('resize', onWindowResize);
      }

      // Window resize handler
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        mainRenderTarget.setSize(
          window.innerWidth * Math.min(window.devicePixelRatio, 2),
          window.innerHeight * Math.min(window.devicePixelRatio, 2)
        );
        backRenderTarget.setSize(
          window.innerWidth * Math.min(window.devicePixelRatio, 2),
          window.innerHeight * Math.min(window.devicePixelRatio, 2)
        );
        
        uniforms.winResolution.value.set(window.innerWidth, window.innerHeight).multiplyScalar(Math.min(window.devicePixelRatio, 2));
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        if (wrapper && isModelReady) {
          const time = Date.now() * 0.001;
          
          // Decay mouse influence over time
          mouseInfluence.x *= 0.98;
          mouseInfluence.y *= 0.98;
          
          // Varying rotation rates with mouse influence
          const xRate = 0.2 + Math.sin(time * 0.1) * 0.15;
          wrapper.rotation.x += xRate * 0.02 + mouseInfluence.y * 0.05;
          
          const yRate = 0.3 + Math.cos(time * 0.08) * 0.2;
          wrapper.rotation.y += yRate * 0.02 + mouseInfluence.x * 0.05;
          
          const zRate = 0.15 + Math.sin(time * 0.12) * 0.1;
          wrapper.rotation.z += zRate * 0.02;
        }
        
        // Glass refraction rendering
        if (mesh) {
          mesh.visible = false;
          
          // Back side render
          renderer.setRenderTarget(backRenderTarget);
          renderer.render(scene, camera);
          
          mesh.material.uniforms.uTexture.value = backRenderTarget.texture;
          mesh.material.side = THREE.BackSide;
          
          mesh.visible = true;
          
          // Front side render
          renderer.setRenderTarget(mainRenderTarget);
          renderer.render(scene, camera);
          
          mesh.material.uniforms.uTexture.value = mainRenderTarget.texture;
          mesh.material.side = THREE.FrontSide;
          
          renderer.setRenderTarget(null);
        }
        
        renderer.render(scene, camera);
      }

      // Initialize when DOM is loaded
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM loaded, ready to initialize Three.js scene');
        init();
        animate();
      });

    </script>
    <!-- WEBFLOW EMBED END -->
  </body>
</html>
